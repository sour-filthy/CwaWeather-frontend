<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taiwan Weather Whack-a-Mole (Debug Mode)</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸŒ¤ï¸</text></svg>">

    <style>
        :root {
            --hole-color: #3e2723;
            --mole-color: #8d6e63;
            --mole-bonked: #e53935;
        }

        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: hidden;
            background-color: #87CEEB;
        }

        h1 { color: #fff; text-shadow: 2px 2px 0 #333; margin-top: 15px; margin-bottom: 5px; z-index: 10; text-align: center; font-size: 1.8rem; font-weight: bold; }
        .subtitle { color: #fff; text-shadow: 2px 2px 0 #333; font-weight: bold; font-size: 1.2rem; margin-bottom: 10px; z-index: 10; text-align: center; letter-spacing: 1px; }

        /* --- åµéŒ¯æ¨¡å¼ï¼šå¼·åˆ¶é¡¯ç¤ºé‚Šæ¡† --- */
        .map-container {
            position: relative;
            width: 95%;
            max-width: 600px;
            height: 650px; 
            margin: 0 auto 50px auto;
            border: 2px solid red; /* ğŸ”´ ç´…æ¡†ï¼šå®¹å™¨ç¯„åœ */
            background: rgba(255, 255, 255, 0.1);
        }

        svg {
            width: 100%;
            height: 100%;
            overflow: visible;
            display: block;
            margin: 0 auto;
            border: 2px dashed green; /* ğŸŸ¢ ç¶ æ¡†ï¼šSVG ç•«å¸ƒç¯„åœ */
        }

        .map-path {
            fill: rgba(255, 255, 255, 0.5);
            stroke: #000; /* âš«ï¸ é»‘ç·šï¼šåœ°åœ–è¼ªå»“ (åµéŒ¯ç”¨) */
            stroke-width: 1px;
            vector-effect: non-scaling-stroke; 
        }

        /* æ´èˆ‡åœ°é¼ æ¨£å¼ */
        .hole-container { position: absolute; width: 50px; height: 50px; transform: translate(-50%, -50%); cursor: pointer; z-index: 1; border: 1px solid yellow; /* ğŸŸ¡ é»ƒæ¡†ï¼šåœ°é¼ æ´ä½ç½® */ }
        .hole-container.active { z-index: 1000; }
        .hole { width: 100%; height: 16px; background: var(--hole-color); border-radius: 50%; position: absolute; bottom: 12px; box-shadow: 0 3px 5px rgba(0,0,0,0.5) inset; z-index: 1; }
        .city-label { position: absolute; top: 6px; width: 80px; left: 50%; transform: translateX(-50%); text-align: center; color: #fff; font-weight: bold; font-size: 12px; text-shadow: 1px 1px 0 #000, -1px -1px 0 #000; pointer-events: none; z-index: 3; }
        .mole { width: 36px; height: 42px; background: var(--mole-color); border-radius: 18px 18px 8px 8px; position: absolute; bottom: 18px; left: 50%; transform: translateX(-50%) scale(0.1); opacity: 0; transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); z-index: 2; display: flex; justify-content: center; }
        .mole::before { content: ''; width: 12px; height: 8px; background: #d7ccc8; border-radius: 50%; position: absolute; top: 18px; }
        .mole::after { content: ''; width: 4px; height: 4px; background: #333; border-radius: 50%; position: absolute; top: 14px; left: 10px; box-shadow: 12px 0 0 #333; }
        .mole.bonked { background: var(--mole-bonked); }
        .mole.bonked::after { content: 'x x'; background: transparent; box-shadow: none; font-size: 12px; font-weight: bold; top: 12px; left: 50%; transform: translateX(-50%); color: #fff; letter-spacing: 2px; }
        .hole-container.active .mole.bonked { transform: translateX(-50%) rotate(25deg) translateY(5px); transition: transform 0.1s; }
        .mole-info { background: white; padding: 4px 6px; border-radius: 6px; text-align: center; font-size: 11px; border: 2px solid #333; position: absolute; top: -65px; width: 85px; left: 50%; transform: translateX(-50%) scale(0.8); opacity: 0; pointer-events: none; transition: all 0.3s; box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
        .mole-info strong { color: #d84315; font-size: 1.1em; display: block; margin-bottom: 2px;}
        .hole-container.active .mole { transform: translateX(-50%) scale(1); opacity: 1; }
        .hole-container.active .mole-info { opacity: 1; transform: translateX(-50%) scale(1); }
        #loading { color: white; font-size: 1.5em; text-shadow: 1px 1px 2px #333; position: absolute; top: 50%; z-index: 100;}
    </style>
</head>
<body>

    <h1>ğŸŒ§ï¸ Debug Mode ğŸŒ¤ï¸</h1>
    <div class="subtitle">è«‹æª¢æŸ¥ Console (F12)</div>
    
    <div id="loading">è¼‰å…¥ä¸­...</div>
    
    <div id="game-board" class="map-container"></div>

    <script>
        // âš ï¸ ç¢ºèª Zeabur å¾Œç«¯ç¶²å€
        const API_URL = 'https://hex-final.zeabur.app/api/weather'; 
        
        const board = document.getElementById('game-board');
        const loading = document.getElementById('loading');
        
        let citiesData = [];
        let geoData = null;
        let autoPlayTimeout = null;

        async function init() {
            console.log("ğŸš€ é–‹å§‹åˆå§‹åŒ–...");
            try {
                // 1. è¼‰å…¥å¤©æ°£
                console.log("ğŸ“¡ æ­£åœ¨æŠ“å–å¤©æ°£è³‡æ–™...");
                const weatherRes = await fetch(API_URL);
                const weatherJson = await weatherRes.json();
                console.log("âœ… å¤©æ°£è³‡æ–™ç‹€æ…‹:", weatherJson.success ? "æˆåŠŸ" : "å¤±æ•—", weatherJson);

                // 2. è¼‰å…¥åœ°åœ–
                console.log("ğŸ—ºï¸ æ­£åœ¨è®€å– tw.json...");
                const mapRes = await fetch('tw.json');
                console.log("ğŸ“„ tw.json HTTP ç‹€æ…‹:", mapRes.status);
                
                if (!mapRes.ok) {
                    throw new Error(`æ‰¾ä¸åˆ° tw.json (Status: ${mapRes.status})`);
                }

                geoData = await mapRes.json();
                console.log("âœ… åœ°åœ–è³‡æ–™è®€å–æˆåŠŸï¼ŒFeature æ•¸é‡:", geoData.features ? geoData.features.length : 0);

                if (weatherJson.success) {
                    citiesData = weatherJson.data;
                    drawMapSystem();
                    loading.style.display = 'none';
                } else {
                    loading.innerText = "å¤©æ°£è³‡æ–™æŠ“å–å¤±æ•—";
                }
            } catch (err) {
                loading.innerText = "âŒ ç™¼ç”ŸéŒ¯èª¤: " + err.message;
                console.error("âŒ åˆå§‹åŒ–éŒ¯èª¤:", err);
            }
        }

        function drawMapSystem() {
            console.log("ğŸ¨ é–‹å§‹ç¹ªè£½åœ°åœ–...");
            board.innerHTML = ''; 

            // --- A. è¨ˆç®—é‚Šç•Œ ---
            let bounds = { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity };
            let pointCount = 0;

            if (!geoData.features || geoData.features.length === 0) {
                console.error("âŒ GeoJSON è£¡é¢æ²’æœ‰ features!");
                return;
            }
            
            geoData.features.forEach(feature => {
                const geometry = feature.geometry;
                if (!geometry) return;

                const coords = geometry.type === 'MultiPolygon' 
                    ? geometry.coordinates.flat(1) 
                    : geometry.coordinates;

                coords.forEach(ring => {
                    ring.forEach(([x, y]) => {
                        pointCount++;
                        if (x < bounds.minX) bounds.minX = x;
                        if (x > bounds.maxX) bounds.maxX = x;
                        if (y < bounds.minY) bounds.minY = y;
                        if (y > bounds.maxY) bounds.maxY = y;
                    });
                });
            });

            console.log(`ğŸ“Š çµ±è¨ˆï¼šå…±è™•ç† ${pointCount} å€‹åº§æ¨™é»`);
            console.log("ğŸ“ è¨ˆç®—å‡ºçš„é‚Šç•Œ (Bounds):", bounds);

            if (bounds.minX === Infinity) {
                console.error("âŒ ç„¡æ³•è¨ˆç®—é‚Šç•Œï¼Œè«‹æª¢æŸ¥ JSON åº§æ¨™æ ¼å¼");
                return;
            }

            // è¨­å®š ViewBox
            const paddingX = (bounds.maxX - bounds.minX) * 0.05;
            const paddingY = (bounds.maxY - bounds.minY) * 0.05;
            const viewBox = `${bounds.minX - paddingX} ${bounds.minY - paddingY} ${(bounds.maxX - bounds.minX) + paddingX*2} ${(bounds.maxY - bounds.minY) + paddingY*2}`;
            
            console.log("ğŸ–¼ï¸ SVG ViewBox è¨­å®šç‚º:", viewBox);

            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute("viewBox", viewBox);
            // å‚ç›´ç¿»è½‰ä¿®æ­£
            svg.style.transform = "scaleY(-1)"; 
            board.appendChild(svg);

            // --- B. ç¹ªè£½è·¯å¾‘ ---
            let drawnCount = 0;
            geoData.features.forEach((feature, idx) => {
                const pathData = generatePath(feature.geometry);
                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                path.setAttribute("d", pathData);
                path.setAttribute("class", "map-path");
                svg.appendChild(path);
                drawnCount++;

                // --- C. æŒ–æ´ ---
                const props = feature.properties;
                const jsonCityName = props.COUNTYNAME || props.name || props.C_Name;
                
                // console.log(`Feature ${idx}: åç¨±=${jsonCityName}`); // å¤ªåµå¯ä»¥è¨»è§£æ‰

                if (jsonCityName) {
                    const center = calculateCentroid(feature.geometry);
                    createHoleAt(jsonCityName, center, bounds);
                }
            });
            console.log(`âœ… å·²ç¹ªè£½ ${drawnCount} å€‹å€å¡Š`);
        }

        function generatePath(geometry) {
            let d = "";
            const coords = geometry.type === 'MultiPolygon' ? geometry.coordinates : [geometry.coordinates];
            coords.forEach(poly => {
                poly.forEach(ring => {
                    d += "M";
                    ring.forEach(([x, y]) => d += `${x},${y} `);
                    d += "Z ";
                });
            });
            return d;
        }

        function calculateCentroid(geometry) {
            let totalX = 0, totalY = 0, count = 0;
            const coords = geometry.type === 'MultiPolygon' ? geometry.coordinates.flat(2) : geometry.coordinates.flat(1);
            coords.forEach(([x, y]) => {
                totalX += x;
                totalY += y;
                count++;
            });
            return { x: totalX / count, y: totalY / count };
        }

        function createHoleAt(cityName, center, bounds) {
            const weatherCity = citiesData.find(c => c.name === cityName);
            
            if (!weatherCity) {
                console.warn(`âš ï¸ æ‰¾ä¸åˆ°å¤©æ°£è³‡æ–™åŒ¹é…: åœ°åœ–åç¨± [${cityName}]`);
                return;
            } else {
                console.log(`ğŸ¯ åŒ¹é…æˆåŠŸ: [${cityName}] -> ç”¢ç”Ÿæ´å£`);
            }

            const paddingX = (bounds.maxX - bounds.minX) * 0.05;
            const paddingY = (bounds.maxY - bounds.minY) * 0.05;
            const minX = bounds.minX - paddingX;
            const minY = bounds.minY - paddingY;
            const width = (bounds.maxX - bounds.minX) + paddingX * 2;
            const height = (bounds.maxY - bounds.minY) + paddingY * 2;

            const leftPct = ((center.x - minX) / width) * 100;
            const topPct = 100 - ((center.y - minY) / height) * 100;

            const container = document.createElement('div');
            container.className = 'hole-container';
            container.style.left = `${leftPct}%`;
            container.style.top = `${topPct}%`;
            
            const index = citiesData.indexOf(weatherCity);
            container.dataset.index = index;

            container.innerHTML = `
                <div class="mole" id="mole-${index}">
                    <div class="mole-info">
                        <strong>${weatherCity.minTemp}-${weatherCity.maxTemp}</strong>
                        <div>${weatherCity.condition}</div>
                        <div>â˜” ${parseInt(weatherCity.pop)}%</div>
                    </div>
                </div>
                <div class="hole"></div>
                <div class="city-label">${weatherCity.name}</div>
            `;

            container.addEventListener('click', (e) => {
                e.stopPropagation();
                whackMole(index);
            });

            board.appendChild(container);
        }

        // éŠæˆ²é‚è¼¯
        function whackMole(index) {
            clearTimeout(autoPlayTimeout);
            document.querySelectorAll('.hole-container').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.mole').forEach(el => el.classList.remove('bonked'));

            const allHoles = document.querySelectorAll('.hole-container');
            const target = Array.from(allHoles).find(h => h.dataset.index == index);

            if (target) {
                const targetMole = target.querySelector('.mole');
                target.classList.add('active');
                targetMole.classList.add('bonked');
                setTimeout(() => {
                    targetMole.classList.remove('bonked');
                }, 500);
            }
        }

        function hideAllMoles() {
            const activeMoles = document.querySelectorAll('.hole-container.active');
            if (activeMoles.length > 0) {
                activeMoles.forEach(el => el.classList.remove('active'));
                autoPlayTimeout = setTimeout(showRandomMole, 1000);
            }
        }

        function showRandomMole() {
            if (citiesData.length === 0) return;
            const randomIdx = Math.floor(Math.random() * citiesData.length);
            document.querySelectorAll('.hole-container').forEach(el => el.classList.remove('active'));
            const allHoles = document.querySelectorAll('.hole-container');
            const target = Array.from(allHoles).find(h => h.dataset.index == randomIdx);
            if(target) target.classList.add('active');
        }

        document.addEventListener('click', (e) => {
            if (!e.target.closest('.hole-container')) {
                hideAllMoles();
            }
        });

        init();
    </script>
</body>
</html>